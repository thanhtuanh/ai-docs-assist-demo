{"ast":null,"code":"/**\n * @license Angular v13.4.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { getDebugNode, RendererFactory2, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\n\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\n\n\nfunction async(fn) {\n  return waitForAsync(fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\n\n\nclass ComponentFixture {\n  constructor(componentRef, ngZone, _autoDetect) {\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    this._autoDetect = _autoDetect;\n    this._isStable = true;\n    this._isDestroyed = false;\n    this._resolve = null;\n    this._promise = null;\n    this._onUnstableSubscription = null;\n    this._onStableSubscription = null;\n    this._onMicrotaskEmptySubscription = null;\n    this._onErrorSubscription = null;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: () => {\n            this._isStable = false;\n          }\n        });\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true; // Check whether there is a pending whenStable() completer to resolve.\n\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve(true);\n\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n        this._onErrorSubscription = ngZone.onError.subscribe({\n          next: error => {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  _tick(checkNoChanges) {\n    this.changeDetectorRef.detectChanges();\n\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n\n\n  detectChanges(checkNoChanges = true) {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => {\n        this._tick(checkNoChanges);\n      });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n\n\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n\n\n  autoDetectChanges(autoDetect = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n\n\n  isStable() {\n    return this._isStable && !this.ngZone.hasPendingMacrotasks;\n  }\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n\n\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => {\n        this._resolve = res;\n      });\n      return this._promise;\n    }\n  }\n\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n\n    return this._renderer;\n  }\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n\n\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n\n    return this.whenStable();\n  }\n  /**\n   * Trigger component destruction.\n   */\n\n\n  destroy() {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n\n      if (this._onUnstableSubscription != null) {\n        this._onUnstableSubscription.unsubscribe();\n\n        this._onUnstableSubscription = null;\n      }\n\n      if (this._onStableSubscription != null) {\n        this._onStableSubscription.unsubscribe();\n\n        this._onStableSubscription = null;\n      }\n\n      if (this._onMicrotaskEmptySubscription != null) {\n        this._onMicrotaskEmptySubscription.unsubscribe();\n\n        this._onMicrotaskEmptySubscription = null;\n      }\n\n      if (this._onErrorSubscription != null) {\n        this._onErrorSubscription.unsubscribe();\n\n        this._onErrorSubscription = null;\n      }\n\n      this._isDestroyed = true;\n    }\n  }\n\n}\n\nfunction scheduleMicroTask(fn) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\nconst fakeAsyncTestModule = _Zone && _Zone[/*#__PURE__*/_Zone.__symbol__('fakeAsyncTest')];\n\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\n\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\n\n\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\n\n\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\n\n\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\n\n\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\n\n\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\n\n\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  const componentResolved = []; // Cache so that we don't fetch the same resource more than once.\n\n  const urlMap = new Map();\n\n  function cachedResourceResolve(url) {\n    let promise = urlMap.get(url);\n\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach((component, type) => {\n    const promises = [];\n\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(template => {\n        component.template = template;\n      }));\n    }\n\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push(''); // pre-allocate array.\n\n      promises.push(cachedResourceResolve(styleUrl).then(style => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\n\nlet componentResourceResolutionQueue = /*#__PURE__*/new Map(); // Track when existing ɵcmp for a Type is waiting on resources.\n\nconst componentDefPendingResolution = /*#__PURE__*/new Set();\n\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\n\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\n\nfunction clearResolutionOfComponentResourcesQueue() {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nfunction restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\n\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet _nextReferenceId = 0;\n\nclass MetadataOverrider {\n  constructor() {\n    this._references = new Map();\n  }\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n\n\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n      }\n\n      setMetadata(props, override.set);\n    }\n\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n\n    return new metadataClass(props);\n  }\n\n}\n\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\n\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      } // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n\n\n      objectIds.set(value, `ɵobj#${nextObjectId++}`); // The first time an object is seen the object itself is serialized.\n\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n\n    return value;\n  };\n\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\n\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n\n  if (!id) {\n    id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n\n  return id;\n}\n\nfunction _valueProps(obj) {\n  const props = []; // regular public props\n\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  }); // getters\n\n  let proto = obj;\n\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n\n  return props;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst reflection = /*#__PURE__*/new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\n\nclass OverrideResolver {\n  constructor() {\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type); // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n\n    return null;\n  }\n\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n\n}\n\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n\n}\n\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n\n}\n\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n\n}\n\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n\n}\n\nvar TestingModuleOverride = /*#__PURE__*/(() => {\n  TestingModuleOverride = TestingModuleOverride || {};\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n  return TestingModuleOverride;\n})();\n\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n\nclass R3TestBedCompiler {\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null; // Testing module configuration\n\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = []; // Queues of components/directives/pipes that should be recompiled.\n\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set(); // Keep track of all components and directives, so we can patch Providers onto defs later.\n\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set(); // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n\n    this.overriddenModules = new Set(); // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    this.componentToModuleScope = new Map(); // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs\n    // TODO: we should support the case with multiple defs on a type\n\n    this.initialNgDefs = new Map(); // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = []; // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.moduleProvidersOverridden = new Set();\n    this.testModuleRef = null;\n\n    class DynamicTestModule {}\n\n    this.testModuleType = DynamicTestModule;\n  }\n\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    } // Enqueue any compilation tasks for imported modules.\n\n\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n  }\n\n  overrideModule(ngModule, override) {\n    this.overriddenModules.add(ngModule); // Compile the module right away.\n\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n\n    this.recompileNgModule(ngModule, metadata); // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n\n  overrideComponent(component, override) {\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n  }\n\n  overrideDirective(directive, override) {\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n\n  overridePipe(pipe, override) {\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n\n  overrideProvider(token, provider) {\n    let providerDef;\n\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n\n    const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef); // Keep overrides grouped by token as well for fast lookups using token\n\n    this.providerOverridesByToken.set(token, providerDef);\n\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[ɵNG_COMP_DEF];\n\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n    };\n\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls(); // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: []\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    } // Set the component's scope to be the testing module.\n\n\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n\n  compileComponents() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.clearComponentResolutionQueue(); // Run compilers for all queued types.\n\n      let needsAsyncResources = this.compileTypesSync(); // compileComponents() should not be async unless it needs to be.\n\n      if (needsAsyncResources) {\n        let resourceLoader;\n\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = this.injector.get(ResourceLoader);\n          }\n\n          return Promise.resolve(resourceLoader.get(url));\n        };\n\n        yield resolveComponentResources(resolver);\n      }\n    });\n  }\n\n  finalize() {\n    // One last compile\n    this.compileTypesSync(); // Create the testing module itself.\n\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides(); // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n\n    this.patchComponentsWithExistingStyles(); // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers(); // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n    ɵsetLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\n   * @internal\n   */\n\n\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesToModule(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\n   * @internal\n   */\n\n\n  _compileNgModuleAsync(moduleType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.queueTypesFromModulesArray([moduleType]);\n      yield this.compileComponents();\n      this.applyProviderOverrides();\n      this.applyProviderOverridesToModule(moduleType);\n      this.applyTransitiveScopes();\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\n   * @internal\n   */\n\n\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n\n      this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n      ɵcompileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n\n      this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n      ɵcompileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n\n      this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n      ɵcompilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n          moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n        });\n      }\n    }\n\n    const moduleToScope = new Map();\n\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n      }\n\n      return moduleToScope.get(moduleType);\n    };\n\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      const moduleScope = getScopeOfModule(moduleType);\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs'); // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n      ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n    });\n    this.componentToModuleScope.clear();\n  }\n\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n\n    this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n\n  applyProviderOverridesToModule(moduleType) {\n    if (this.moduleProvidersOverridden.has(moduleType)) {\n      return;\n    }\n\n    this.moduleProvidersOverridden.add(moduleType);\n    const injectorDef = moduleType[ɵNG_INJ_DEF];\n\n    if (this.providerOverridesByToken.size > 0) {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(moduleType) || [])];\n\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n        this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      } // Apply provider overrides to imported modules recursively\n\n\n      const moduleDef = moduleType[ɵNG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n\n      for (const importedModule of imports) {\n        this.applyProviderOverridesToModule(importedModule);\n      } // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n\n\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n    ɵcompileNgModuleDefs(ngModule, metadata);\n  }\n\n  queueType(type, moduleType) {\n    const component = this.resolvers.component.resolve(type);\n\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n\n      this.seenComponents.add(type); // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n\n      return;\n    }\n\n    const directive = this.resolvers.directive.resolve(type);\n\n    if (directive) {\n      if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n\n      this.seenDirectives.add(type);\n      return;\n    }\n\n    const pipe = this.resolvers.pipe.resolve(type);\n\n    if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule while processing the imports and exports of an\n    // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n    // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n    const processedNgModuleDefs = new Set();\n\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n\n          if (processedNgModuleDefs.has(def)) {\n            continue;\n          }\n\n          processedNgModuleDefs.add(def); // Look through declarations, imports, and exports, and queue\n          // everything found there.\n\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        }\n      }\n    };\n\n    queueTypesFromModulesArrayRecur(arr);\n  } // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n\n\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n\n            continue;\n          }\n\n          seenModules.add(value);\n\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          } // Examine module imports recursively to look for overridden modules.\n\n\n          const moduleDef = value[ɵNG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      this.initialNgDefs.set(type, [prop, currentDef]);\n    }\n  }\n\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n\n\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n\n\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    }); // Restore initial component/directive/pipe defs\n\n    this.initialNgDefs.forEach((value, type) => {\n      const [prop, descriptor] = value;\n\n      if (!descriptor) {\n        // Delete operations are generally undesirable since they have performance implications\n        // on objects they were applied to. In this particular case, situations where this code\n        // is invoked should be quite rare to cause any noticeable impact, since it's applied\n        // only to some test cases (for example when class with no annotations extends some\n        // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n        // its original state (before applying overrides and running tests).\n        delete type[prop];\n      } else {\n        Object.defineProperty(type, prop, descriptor);\n      }\n    });\n    this.initialNgDefs.clear();\n    this.moduleProvidersOverridden.clear();\n    this.restoreComponentResolutionQueue(); // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n\n    ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n  }\n\n  compileTestModule() {\n    class RootScopeModule {}\n\n    ɵcompileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides]\n    });\n    const ngZone = new NgZone({\n      enableLongStackTrace: true\n    });\n    const providers = [{\n      provide: NgZone,\n      useValue: ngZone\n    }, {\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []]; // clang-format off\n\n    ɵcompileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    },\n    /* allowDuplicateDeclarationsInRoot */\n    true); // clang-format on\n\n    this.applyProviderOverridesToModule(this.testModuleType);\n  }\n\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    } // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n\n\n    class CompilerModule {}\n\n    ɵcompileNgModuleDefs(CompilerModule, {\n      providers\n    });\n    const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n    this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n    return this._injector;\n  } // get overrides for a specific provider (if any)\n\n\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return []; // There are two flattening operations here. The inner flatten() operates on the metadata's\n    // providers and applies a mapping function which retrieves overrides for each incoming\n    // provider. The outer flatten() then flattens the produced overrides array. If this is not\n    // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n\n    return flatten(flatten(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flatten(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set(); // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token); // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n\n          final.unshift(Object.assign(Object.assign({}, provider), {\n            multi: false\n          }));\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n\n}\n\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\n\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten(values, mapFn) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value, mapFn));\n    } else {\n      out.push(mapFn ? mapFn(value) : value);\n    }\n  });\n  return out;\n}\n\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\n\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\n\nclass R3TestCompiler {\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n\n    return new ɵNgModuleFactory(moduleType);\n  }\n\n  compileModuleAsync(moduleType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.testBed._compileNgModuleAsync(moduleType);\n      return new ɵNgModuleFactory(moduleType);\n    });\n  }\n\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  compileModuleAndAllComponentsAsync(moduleType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ngModuleFactory = yield this.compileModuleAsync(moduleType);\n\n      const componentFactories = this.testBed._getComponentFactories(moduleType);\n\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    });\n  }\n\n  clearCache() {}\n\n  clearCacheFor(type) {}\n\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n\n    return meta && meta.id || undefined;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Whether test modules should be torn down by default. */\n\n\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\n\nclass TestComponentRenderer {\n  insertRootElement(rootElementId) {}\n\n  removeAllRootElements() {}\n\n}\n/**\n * @publicApi\n */\n\n\nconst ComponentFixtureAutoDetect = /*#__PURE__*/new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\n\nconst ComponentFixtureNoNgZone = /*#__PURE__*/new InjectionToken('ComponentFixtureNoNgZone');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nclass TestBedRender3 {\n  constructor() {\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    this._globalCompilationChecked = false;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n    const testBed = _getTestBedRender3();\n\n    testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n    return testBed;\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n\n\n  static resetTestEnvironment() {\n    _getTestBedRender3().resetTestEnvironment();\n  }\n\n  static configureCompiler(config) {\n    _getTestBedRender3().configureCompiler(config);\n\n    return TestBedRender3;\n  }\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n\n\n  static configureTestingModule(moduleDef) {\n    _getTestBedRender3().configureTestingModule(moduleDef);\n\n    return TestBedRender3;\n  }\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n\n\n  static compileComponents() {\n    return _getTestBedRender3().compileComponents();\n  }\n\n  static overrideModule(ngModule, override) {\n    _getTestBedRender3().overrideModule(ngModule, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideComponent(component, override) {\n    _getTestBedRender3().overrideComponent(component, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideDirective(directive, override) {\n    _getTestBedRender3().overrideDirective(directive, override);\n\n    return TestBedRender3;\n  }\n\n  static overridePipe(pipe, override) {\n    _getTestBedRender3().overridePipe(pipe, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideTemplate(component, template) {\n    _getTestBedRender3().overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n\n    return TestBedRender3;\n  }\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n\n\n  static overrideTemplateUsingTestingModule(component, template) {\n    _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n\n    return TestBedRender3;\n  }\n\n  static overrideProvider(token, provider) {\n    _getTestBedRender3().overrideProvider(token, provider);\n\n    return TestBedRender3;\n  }\n\n  static inject(token, notFoundValue, flags) {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n\n  static createComponent(component) {\n    return _getTestBedRender3().createComponent(component);\n  }\n\n  static resetTestingModule() {\n    _getTestBedRender3().resetTestingModule();\n\n    return TestBedRender3;\n  }\n\n  static shouldTearDownTestingModule() {\n    return _getTestBedRender3().shouldTearDownTestingModule();\n  }\n\n  static tearDownTestingModule() {\n    _getTestBedRender3().tearDownTestingModule();\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  initTestEnvironment(ngModule, platform, summariesOrOptions) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    } // If `summariesOrOptions` is a function, it means that it's\n    // an AOT summaries factory which Ivy doesn't support.\n\n\n    TestBedRender3._environmentTeardownOptions = typeof summariesOrOptions === 'function' ? undefined : summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.teardown;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n\n\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedRender3._environmentTeardownOptions = undefined;\n  }\n\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    ɵresetCompiledComponents();\n\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule); // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n      }\n    }\n  }\n\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('the Render3 compiler JiT mode is not configurable !');\n    }\n\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n  }\n\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module'); // Trigger module scoping queue flush before executing other TestBed operations in a test.\n    // This is needed for the first test invocation to ensure that globally declared modules have\n    // their components scoped properly. See the `checkGlobalCompilationFinished` function\n    // description for additional info.\n\n    this.checkGlobalCompilationFinished(); // Always re-assign the teardown options, even if they're undefined.\n    // This ensures that we don't carry the options between tests.\n\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this.compiler.configureTestingModule(moduleDef);\n  }\n\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n\n  inject(token, notFoundValue, flags) {\n    if (token === TestBedRender3) {\n      return this;\n    }\n\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n  }\n\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n  }\n\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n  }\n\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n  }\n\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n  }\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n\n\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n  }\n\n  createComponent(type) {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n    const componentDef = type.ɵcmp;\n\n    if (!componentDef) {\n      throw new Error(`It looks like '${ɵstringify(type)}' has not been IVY compiled - it has no 'ɵcmp' field`);\n    } // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n    const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const componentFactory = new ɵRender3ComponentFactory(componentDef);\n\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return new ComponentFixture(componentRef, ngZone, autoDetect);\n    };\n\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n\n    this._activeFixtures.push(fixture);\n\n    return fixture;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n\n\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n\n    return this._compiler;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n\n\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n\n    return this._testModuleRef;\n  }\n\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n\n\n  checkGlobalCompilationFinished() {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this._globalCompilationChecked && this._testModuleRef === null) {\n      ɵflushModuleScopingQueueAsMuchAsPossible();\n    }\n\n    this._globalCompilationChecked = true;\n  }\n\n  destroyActiveFixtures() {\n    let errorCount = 0;\n\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n\n    this._activeFixtures = [];\n\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n\n  shouldRethrowTeardownErrors() {\n    var _a, _b;\n\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedRender3._environmentTeardownOptions; // If the new teardown behavior hasn't been configured, preserve the old behavior.\n\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    } // Otherwise use the configured behavior or default to rethrowing.\n\n\n    return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : this.shouldTearDownTestingModule();\n  }\n\n  shouldTearDownTestingModule() {\n    var _a, _b, _c, _d;\n\n    return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedRender3._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n\n  tearDownTestingModule() {\n    var _a; // If the module ref has already been destroyed, we won't be able to get a test renderer.\n\n\n    if (this._testModuleRef === null) {\n      return;\n    } // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n\n\n    const testRenderer = this.inject(TestComponentRenderer);\n\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      (_a = testRenderer.removeAllRootElements) === null || _a === void 0 ? void 0 : _a.call(testRenderer);\n    }\n  }\n\n}\n\nlet testBed;\n\nfunction _getTestBedRender3() {\n  return testBed = testBed || new TestBedRender3();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\n\n\nconst TestBed = TestBedRender3;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\n\nconst getTestBed = _getTestBedRender3;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\n\nfunction inject(tokens, fn) {\n  const testBed = getTestBed(); // Not using an arrow function to preserve context passed from call site\n\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\n\n\nclass InjectSetupWrapper {\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n\n  _addModule() {\n    const moduleDef = this._moduleDef();\n\n    if (moduleDef) {\n      getTestBed().configureTestingModule(moduleDef);\n    }\n  }\n\n  inject(tokens, fn) {\n    const self = this; // Not using an arrow function to preserve context passed from call site\n\n    return function () {\n      self._addModule();\n\n      return inject(tokens, fn).call(this);\n    };\n  }\n\n}\n\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = getTestBed();\n\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n\n      return fn.apply(this);\n    };\n  }\n\n  return new InjectSetupWrapper(() => moduleDef);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _global = typeof window === 'undefined' ? global : window; // Reset the test providers and the fake async zone before each test.\n\n\nif (_global.beforeEach) {\n  /*#__PURE__*/\n  _global.beforeEach( /*#__PURE__*/getCleanupHook(false));\n} // We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n\n\nif (_global.afterEach) {\n  /*#__PURE__*/\n  _global.afterEach( /*#__PURE__*/getCleanupHook(true));\n}\n\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    // TODO(alxhub): find a better type here\n    if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      TestBed.resetTestingModule();\n      resetFakeAsyncZone();\n    }\n  };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\n\n\nconst __core_private_testing_placeholder__ = '';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider }; //# sourceMappingURL=testing.mjs.map","map":null,"metadata":{},"sourceType":"module"}